" Synthentix is an aggregation entity "
type Synthetix @entity {
  id: ID!

  " number of stakers currently staking "
  issuers: BigInt!

  " number of addresses which hold SNX "
  snxHolders: BigInt!
}

" An individual Issuer "
type Issuer @entity {
  id: ID!
}

" An individual SNX holder (always overridden with their latest information) "
type SNXHolder @entity {
  " address of holder "
  id: ID!

  " last block where an event happened "
  block: BigInt!

  " last time where an event happened "
  timestamp: BigInt!

  " current SNX balance of the holder "
  balanceOf: BigDecimal

  # the following will be null before multicurrency (v2) release
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal

  " SNX which can be spent as of last event "
  transferable: BigDecimal

  initialDebtOwnership: BigInt

  debtEntryAtIndex: BigInt

  " number of claims performed "
  claims: BigInt

  " number of mints performed "
  mints: BigInt
}

" A historical debt tracker "
type DebtSnapshot @entity {
  id: ID!

  " last block where an event happened "
  block: BigInt!

  " last time when an event happened "
  timestamp: BigInt!

  " address for which these statistics are applicable "
  account: Bytes! # address
  balanceOf: BigDecimal # early on it was possible this wouldn't have a value (pre v2)
  # the following will be null before multicurrency (v2) release

  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal

  " sUSD of debt as of last event "
  debtBalanceOf: BigDecimal

  " sUSD debt portion a user had at last index "
  initialDebtOwnership: BigDecimal

  " debt entry when `initialDebtOwnership` applies"
  debtEntryAtIndex: BigInt
}

type DailyIssued @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!

  " amount issued "
  value: BigDecimal!

  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

type DailyBurned @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!

  " amount burned "
  value: BigDecimal!

  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

" Tracks this event from various Synth.sol instances "
type Issued @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Burned tracks this event from various Synth.sol instances "
type Burned @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal! # uint256
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type RewardEscrowHolder @entity {
  " address which holds a rewardescrow "
  id: ID!

  " amount of tokens remaining to be claimed from the escrow "
  balanceOf: BigDecimal!

  " amount of SNX claimed from the escrow "
  vestedBalanceOf: BigDecimal!
}

" Tracks this event from Synthetix.sol "
type FeesClaimed @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal! # uint256
  rewards: BigDecimal! # uint256
  block: BigInt!
  timestamp: BigInt!
}

type TotalActiveStaker @entity {
  " single value "
  id: ID!

  " number of stakers seen "
  count: BigInt!
}

type TotalDailyActiveStaker @entity {
  " unix timestamp at beginning of day relevant to this statistic "
  id: ID!

  " unix timestamp as a BigInt (so it can be filtered) "
  timestamp: BigInt!

  " number of stakers seen on this day "
  count: BigInt!
}

type ActiveStaker @entity {
  id: ID!
}

type SynthByCurrencyKey @entity {
  " currency key "
  id: ID!
  proxyAddress: Bytes!
}

type Synth @entity {
  id: ID!
  name: String!
  symbol: String!
}

" we dont query these entities but only use it to store aggregate data we need during syncing "
type SynthExchange @entity {
  id: ID!
  account: Exchanger! # address
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal! # uint256
  fromAmountInUSD: BigDecimal! # from Amount including fees
  toAmount: BigDecimal! # uint256
  toAmountInUSD: BigDecimal! # to Amount without fees
  feesInUSD: BigDecimal!
  toAddress: Bytes! # address
  timestamp: BigInt!
  gasPrice: BigInt!
}

type Exchanger @entity {
  " hex address in lowercase (and for non global: hex address in lowercase-$timestamp-$period-$bucketMagnitude-$synth "
  id: ID!

  " timestamp of the beginning of the time period this represents, or 0 for no period filter "
  timestamp: BigInt!

  " number of seconds the data covers after `timestamp`, or 0 for no period filter "
  period: BigInt!

  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!

  " synth to filter by "
  synth: Synth

  " when the user first exchanged "
  firstSeen: BigInt!

  " when the user last exchanged "
  lastSeen: BigInt!

  " nubmer of trades by account "
  trades: BigInt!

  " synth value exchanged in USD units by account "
  exchangeUSDTally: BigDecimal!

  " synth value received in fees in USD units from account "
  totalFeesGeneratedInUSD: BigDecimal!

  " balances "
  balances: [LatestSynthBalance!]! @derivedFrom(field: "account")

  " exchanges "
  exchanges: [SynthExchange!]! @derivedFrom(field: "account")
}

type LatestSynthBalance @entity {
  " account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: Exchanger
  timestamp: BigInt!
  synth: Synth
}
